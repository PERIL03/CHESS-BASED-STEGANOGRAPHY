{"ast":null,"code":"/**\n * X402 Payment SDK\n * Simulated implementation for chess steganography micropayments\n */\n\nclass X402SDK {\n  constructor(options = {}) {\n    this.apiUrl = options.apiUrl || 'http://localhost:8001';\n    this.walletProvider = options.walletProvider;\n    this.networkConfig = {\n      chainId: options.chainId || 1,\n      name: options.network || 'ethereum',\n      currency: 'ETH'\n    };\n    this.paymentProtocol = 'x402-v1.0';\n  }\n\n  /**\n   * Initialize a payment session\n   * @param {Object} paymentRequest - Payment request details\n   * @returns {Promise<Object>} Payment session data\n   */\n  async initiatePayment(paymentRequest) {\n    try {\n      const {\n        walletAddress,\n        operation,\n        fileHash,\n        amount\n      } = paymentRequest;\n      if (!walletAddress) {\n        throw new Error('Wallet address is required for X402 payments');\n      }\n      if (!operation || !['encode', 'decode'].includes(operation)) {\n        throw new Error('Valid operation (encode/decode) is required');\n      }\n      if (!fileHash) {\n        throw new Error('File hash is required for payment verification');\n      }\n\n      // Call the backend API to initiate payment\n      const response = await fetch(`${this.apiUrl}/api/payment/initiate`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-Protocol': this.paymentProtocol\n        },\n        body: JSON.stringify({\n          wallet_address: walletAddress,\n          operation,\n          file_hash: fileHash,\n          protocol: this.paymentProtocol,\n          network: this.networkConfig.name\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.message || 'Payment initiation failed');\n      }\n      const paymentData = await response.json();\n      return {\n        success: true,\n        transactionId: paymentData.transaction_id,\n        amount: paymentData.payment_amount,\n        amountEth: paymentData.payment_amount_eth,\n        paymentAddress: paymentData.payment_address,\n        expiresIn: paymentData.expires_in,\n        protocol: paymentData.x402_protocol,\n        message: paymentData.message\n      };\n    } catch (error) {\n      console.error('X402 Payment Initiation Error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Process the payment through the wallet\n   * @param {Object} paymentSession - Payment session from initiatePayment\n   * @returns {Promise<Object>} Transaction result\n   */\n  async processPayment(paymentSession) {\n    try {\n      if (!this.walletProvider) {\n        throw new Error('Wallet provider not configured');\n      }\n      const {\n        transactionId,\n        amount,\n        paymentAddress\n      } = paymentSession;\n\n      // Simulate wallet transaction (in production, this would be real)\n      const transactionParams = {\n        to: paymentAddress,\n        value: `0x${parseInt(amount).toString(16)}`,\n        // Convert wei to hex\n        gas: '0x5208',\n        // Standard gas limit for ETH transfer\n        gasPrice: '0x9184e72a000' // 10 Gwei\n      };\n\n      // Simulate the transaction\n      console.log('Processing X402 payment with params:', transactionParams);\n\n      // In a real implementation, this would call:\n      // const txHash = await this.walletProvider.request({\n      //   method: 'eth_sendTransaction',\n      //   params: [transactionParams],\n      // });\n\n      // For demo purposes, generate a simulated transaction hash\n      const simulatedTxHash = this.generateSimulatedTxHash();\n      return {\n        success: true,\n        transactionId,\n        txHash: simulatedTxHash,\n        message: 'Payment processed successfully'\n      };\n    } catch (error) {\n      console.error('X402 Payment Processing Error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Verify payment completion\n   * @param {Object} paymentResult - Result from processPayment\n   * @returns {Promise<Object>} Verification result\n   */\n  async verifyPayment(paymentResult) {\n    try {\n      const {\n        transactionId,\n        txHash\n      } = paymentResult;\n      const response = await fetch(`${this.apiUrl}/api/payment/verify`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-Protocol': this.paymentProtocol\n        },\n        body: JSON.stringify({\n          transaction_id: transactionId,\n          tx_hash: txHash,\n          protocol: this.paymentProtocol\n        })\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.message || 'Payment verification failed');\n      }\n      const verificationData = await response.json();\n      return {\n        success: verificationData.success,\n        status: verificationData.status,\n        message: verificationData.message,\n        transactionId,\n        txHash\n      };\n    } catch (error) {\n      console.error('X402 Payment Verification Error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Complete payment flow (initiate + process + verify)\n   * @param {Object} paymentRequest - Payment request details\n   * @returns {Promise<Object>} Complete payment result\n   */\n  async completePayment(paymentRequest) {\n    try {\n      // Step 1: Initiate payment\n      const paymentSession = await this.initiatePayment(paymentRequest);\n\n      // Step 2: Process payment through wallet\n      const paymentResult = await this.processPayment(paymentSession);\n\n      // Step 3: Verify payment\n      const verificationResult = await this.verifyPayment(paymentResult);\n      return {\n        success: verificationResult.success,\n        transactionId: paymentResult.transactionId,\n        txHash: paymentResult.txHash,\n        amount: paymentSession.amountEth,\n        status: verificationResult.status,\n        message: verificationResult.message\n      };\n    } catch (error) {\n      console.error('X402 Complete Payment Error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get payment status\n   * @param {string} transactionId - Transaction ID to check\n   * @returns {Promise<Object>} Payment status\n   */\n  async getPaymentStatus(transactionId) {\n    try {\n      const response = await fetch(`${this.apiUrl}/api/payment/status/${transactionId}`, {\n        headers: {\n          'X-Protocol': this.paymentProtocol\n        }\n      });\n      if (!response.ok) {\n        throw new Error('Failed to fetch payment status');\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('X402 Payment Status Error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Calculate file hash for payment verification\n   * @param {File} file - File to calculate hash for\n   * @returns {Promise<string>} SHA-256 hash of file\n   */\n  async calculateFileHash(file) {\n    try {\n      const arrayBuffer = await file.arrayBuffer();\n      const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);\n      const hashArray = Array.from(new Uint8Array(hashBuffer));\n      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n    } catch (error) {\n      console.error('File hash calculation error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Generate simulated transaction hash for demo purposes\n   * @returns {string} Simulated transaction hash\n   */\n  generateSimulatedTxHash() {\n    const chars = '0123456789abcdef';\n    let result = '0x';\n    for (let i = 0; i < 64; i++) {\n      result += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return result;\n  }\n\n  /**\n   * Get payment configuration\n   * @returns {Object} Payment configuration\n   */\n  getConfig() {\n    return {\n      protocol: this.paymentProtocol,\n      network: this.networkConfig,\n      apiUrl: this.apiUrl,\n      supportedOperations: ['encode', 'decode'],\n      paymentAmounts: {\n        encode: '0.002',\n        // ETH\n        decode: '0.001' // ETH\n      }\n    };\n  }\n\n  /**\n   * Validate payment request\n   * @param {Object} paymentRequest - Payment request to validate\n   * @returns {Object} Validation result\n   */\n  validatePaymentRequest(paymentRequest) {\n    const errors = [];\n    if (!paymentRequest.walletAddress) {\n      errors.push('Wallet address is required');\n    }\n    if (!paymentRequest.operation || !['encode', 'decode'].includes(paymentRequest.operation)) {\n      errors.push('Valid operation (encode/decode) is required');\n    }\n    if (!paymentRequest.fileHash) {\n      errors.push('File hash is required');\n    }\n    return {\n      valid: errors.length === 0,\n      errors\n    };\n  }\n}\n\n// Export singleton instance\nconst x402SDK = new X402SDK();\nexport default x402SDK;\nexport { X402SDK };","map":{"version":3,"names":["X402SDK","constructor","options","apiUrl","walletProvider","networkConfig","chainId","name","network","currency","paymentProtocol","initiatePayment","paymentRequest","walletAddress","operation","fileHash","amount","Error","includes","response","fetch","method","headers","body","JSON","stringify","wallet_address","file_hash","protocol","ok","errorData","json","message","paymentData","success","transactionId","transaction_id","payment_amount","amountEth","payment_amount_eth","paymentAddress","payment_address","expiresIn","expires_in","x402_protocol","error","console","processPayment","paymentSession","transactionParams","to","value","parseInt","toString","gas","gasPrice","log","simulatedTxHash","generateSimulatedTxHash","txHash","verifyPayment","paymentResult","tx_hash","verificationData","status","completePayment","verificationResult","getPaymentStatus","calculateFileHash","file","arrayBuffer","hashBuffer","crypto","subtle","digest","hashArray","Array","from","Uint8Array","map","b","padStart","join","chars","result","i","charAt","Math","floor","random","length","getConfig","supportedOperations","paymentAmounts","encode","decode","validatePaymentRequest","errors","push","valid","x402SDK"],"sources":["/Users/rishuraj/Desktop/ROOKHIDE_LOCAL/frontend/src/utils/x402SDK.js"],"sourcesContent":["/**\n * X402 Payment SDK\n * Simulated implementation for chess steganography micropayments\n */\n\nclass X402SDK {\n  constructor(options = {}) {\n    this.apiUrl = options.apiUrl || 'http://localhost:8001';\n    this.walletProvider = options.walletProvider;\n    this.networkConfig = {\n      chainId: options.chainId || 1,\n      name: options.network || 'ethereum',\n      currency: 'ETH',\n    };\n    this.paymentProtocol = 'x402-v1.0';\n  }\n\n  /**\n   * Initialize a payment session\n   * @param {Object} paymentRequest - Payment request details\n   * @returns {Promise<Object>} Payment session data\n   */\n  async initiatePayment(paymentRequest) {\n    try {\n      const { walletAddress, operation, fileHash, amount } = paymentRequest;\n\n      if (!walletAddress) {\n        throw new Error('Wallet address is required for X402 payments');\n      }\n\n      if (!operation || !['encode', 'decode'].includes(operation)) {\n        throw new Error('Valid operation (encode/decode) is required');\n      }\n\n      if (!fileHash) {\n        throw new Error('File hash is required for payment verification');\n      }\n\n      // Call the backend API to initiate payment\n      const response = await fetch(`${this.apiUrl}/api/payment/initiate`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-Protocol': this.paymentProtocol,\n        },\n        body: JSON.stringify({\n          wallet_address: walletAddress,\n          operation,\n          file_hash: fileHash,\n          protocol: this.paymentProtocol,\n          network: this.networkConfig.name,\n        }),\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.message || 'Payment initiation failed');\n      }\n\n      const paymentData = await response.json();\n\n      return {\n        success: true,\n        transactionId: paymentData.transaction_id,\n        amount: paymentData.payment_amount,\n        amountEth: paymentData.payment_amount_eth,\n        paymentAddress: paymentData.payment_address,\n        expiresIn: paymentData.expires_in,\n        protocol: paymentData.x402_protocol,\n        message: paymentData.message,\n      };\n    } catch (error) {\n      console.error('X402 Payment Initiation Error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Process the payment through the wallet\n   * @param {Object} paymentSession - Payment session from initiatePayment\n   * @returns {Promise<Object>} Transaction result\n   */\n  async processPayment(paymentSession) {\n    try {\n      if (!this.walletProvider) {\n        throw new Error('Wallet provider not configured');\n      }\n\n      const { transactionId, amount, paymentAddress } = paymentSession;\n\n      // Simulate wallet transaction (in production, this would be real)\n      const transactionParams = {\n        to: paymentAddress,\n        value: `0x${parseInt(amount).toString(16)}`, // Convert wei to hex\n        gas: '0x5208', // Standard gas limit for ETH transfer\n        gasPrice: '0x9184e72a000', // 10 Gwei\n      };\n\n      // Simulate the transaction\n      console.log('Processing X402 payment with params:', transactionParams);\n      \n      // In a real implementation, this would call:\n      // const txHash = await this.walletProvider.request({\n      //   method: 'eth_sendTransaction',\n      //   params: [transactionParams],\n      // });\n\n      // For demo purposes, generate a simulated transaction hash\n      const simulatedTxHash = this.generateSimulatedTxHash();\n\n      return {\n        success: true,\n        transactionId,\n        txHash: simulatedTxHash,\n        message: 'Payment processed successfully',\n      };\n    } catch (error) {\n      console.error('X402 Payment Processing Error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Verify payment completion\n   * @param {Object} paymentResult - Result from processPayment\n   * @returns {Promise<Object>} Verification result\n   */\n  async verifyPayment(paymentResult) {\n    try {\n      const { transactionId, txHash } = paymentResult;\n\n      const response = await fetch(`${this.apiUrl}/api/payment/verify`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-Protocol': this.paymentProtocol,\n        },\n        body: JSON.stringify({\n          transaction_id: transactionId,\n          tx_hash: txHash,\n          protocol: this.paymentProtocol,\n        }),\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.message || 'Payment verification failed');\n      }\n\n      const verificationData = await response.json();\n\n      return {\n        success: verificationData.success,\n        status: verificationData.status,\n        message: verificationData.message,\n        transactionId,\n        txHash,\n      };\n    } catch (error) {\n      console.error('X402 Payment Verification Error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Complete payment flow (initiate + process + verify)\n   * @param {Object} paymentRequest - Payment request details\n   * @returns {Promise<Object>} Complete payment result\n   */\n  async completePayment(paymentRequest) {\n    try {\n      // Step 1: Initiate payment\n      const paymentSession = await this.initiatePayment(paymentRequest);\n\n      // Step 2: Process payment through wallet\n      const paymentResult = await this.processPayment(paymentSession);\n\n      // Step 3: Verify payment\n      const verificationResult = await this.verifyPayment(paymentResult);\n\n      return {\n        success: verificationResult.success,\n        transactionId: paymentResult.transactionId,\n        txHash: paymentResult.txHash,\n        amount: paymentSession.amountEth,\n        status: verificationResult.status,\n        message: verificationResult.message,\n      };\n    } catch (error) {\n      console.error('X402 Complete Payment Error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get payment status\n   * @param {string} transactionId - Transaction ID to check\n   * @returns {Promise<Object>} Payment status\n   */\n  async getPaymentStatus(transactionId) {\n    try {\n      const response = await fetch(`${this.apiUrl}/api/payment/status/${transactionId}`, {\n        headers: {\n          'X-Protocol': this.paymentProtocol,\n        },\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to fetch payment status');\n      }\n\n      return await response.json();\n    } catch (error) {\n      console.error('X402 Payment Status Error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Calculate file hash for payment verification\n   * @param {File} file - File to calculate hash for\n   * @returns {Promise<string>} SHA-256 hash of file\n   */\n  async calculateFileHash(file) {\n    try {\n      const arrayBuffer = await file.arrayBuffer();\n      const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);\n      const hashArray = Array.from(new Uint8Array(hashBuffer));\n      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n    } catch (error) {\n      console.error('File hash calculation error:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Generate simulated transaction hash for demo purposes\n   * @returns {string} Simulated transaction hash\n   */\n  generateSimulatedTxHash() {\n    const chars = '0123456789abcdef';\n    let result = '0x';\n    for (let i = 0; i < 64; i++) {\n      result += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return result;\n  }\n\n  /**\n   * Get payment configuration\n   * @returns {Object} Payment configuration\n   */\n  getConfig() {\n    return {\n      protocol: this.paymentProtocol,\n      network: this.networkConfig,\n      apiUrl: this.apiUrl,\n      supportedOperations: ['encode', 'decode'],\n      paymentAmounts: {\n        encode: '0.002', // ETH\n        decode: '0.001', // ETH\n      },\n    };\n  }\n\n  /**\n   * Validate payment request\n   * @param {Object} paymentRequest - Payment request to validate\n   * @returns {Object} Validation result\n   */\n  validatePaymentRequest(paymentRequest) {\n    const errors = [];\n\n    if (!paymentRequest.walletAddress) {\n      errors.push('Wallet address is required');\n    }\n\n    if (!paymentRequest.operation || !['encode', 'decode'].includes(paymentRequest.operation)) {\n      errors.push('Valid operation (encode/decode) is required');\n    }\n\n    if (!paymentRequest.fileHash) {\n      errors.push('File hash is required');\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n    };\n  }\n}\n\n// Export singleton instance\nconst x402SDK = new X402SDK();\n\nexport default x402SDK;\nexport { X402SDK };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}